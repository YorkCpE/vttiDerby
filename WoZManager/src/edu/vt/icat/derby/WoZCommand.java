package edu.vt.icat.derby;

import oscP5.OscMessage;
import edu.vt.icat.derby.DerbyCar.LicenseColor;
import edu.vt.icat.derby.DerbyCar.LicenseShape;

/**
 * WoZCommands are commands that can be sent to the Arduino. They are generated by the WoZClient or WoZManager and then sent over the Xbee network
 * @author Jason Forsyth
 *
 */
public class WoZCommand 
{
	//OSC Message types for each command
	public static final String LANE_VIOLATION="/laneViolation";
	public static final String COLLISION_WARNING="/collisionWarning";
	public static final String LAP_STARTSTOP="/lapStartStop";
	public static final String SYSTEM_CHECK="/systemCheck";
	public static final String IS_ONLINE="/isOnline";

	//Arduino that the command should target
	private String target;
	
	//actual command we want to execute
	private String command;
	
	//any arguments or additional information
	private String args;

	//Command byte to indicate which command should execute when 
	//received over Xbee
	private static final byte LANE_VIOLATION_BYTE=0xA;
	private static final byte COLLISION_WARNING_BYTE=0xB;
	private static final byte LAP_STARTSTOP_BYTE=0xC;
	private static final byte HEARTBEAT_BYTE=0xD;
	private static final byte SYSTEM_CHECK_BYTE=0xE;

	public WoZCommand(LicenseColor color, LicenseShape shape, String _command, String _args) 
	{
		target=color+","+shape;
		command=_command;
		args=_args;
	}

	/**
	 * Convert this command into an OSC message for transmission to the WoZManager
	 * @return An OSCMessage suitable for transmission.
	 */
	public OscMessage generateOscMessage() 
	{
		OscMessage newMessage = new OscMessage(command);
		newMessage.add(target);
		newMessage.add(args);

		return newMessage;
	}

	public String getTarget()
	{
		return target;
	}

	/**
	 * Generate the binary payload for this message to send over Xbee. Each packet is 4 bytes {command byte, arg[0], args[1], checksum}.
	 * @return Binary payload
	 */
	public int[] generateXbeePayload()
	{	
		//lookup the appropriate command byte
		byte commandByte=0x0;
		if(command.equals(LANE_VIOLATION))
		{
			commandByte=LANE_VIOLATION_BYTE;
		}
		else if(command.equals(COLLISION_WARNING))
		{
			commandByte=COLLISION_WARNING_BYTE;
		}
		else if(command.equals(LAP_STARTSTOP))
		{
			commandByte=LAP_STARTSTOP_BYTE;
		}
		else if(command.equals(IS_ONLINE))
		{
			commandByte=HEARTBEAT_BYTE;
		}
		else if(command.equals(SYSTEM_CHECK))
		{
			commandByte=SYSTEM_CHECK_BYTE;
		}
		else
		{
			commandByte=0x0;
		}

		//generate the argument bytes (if any)
		byte[] argBytes={0x0,0x0};

		if(args!=null)
		{

			if(args.getBytes().length==1)
			{
				byte b = args.getBytes()[0];
				argBytes= new byte[]{0x0,b};
			}
			else if(args.getBytes().length>=2)
			{
				byte a = args.getBytes()[0];
				byte b = args.getBytes()[1];
				argBytes= new byte[]{a,b};
			}
		}

		//generate a checksum
		byte checkSum=(byte) (commandByte^argBytes[0]^argBytes[1]^0xff);
		
		//package everything together
		int[] payload={commandByte,argBytes[0],argBytes[1],checkSum};
		
		return payload;
	}

	public String getCommand() 
	{
		return this.command;
	}
}
